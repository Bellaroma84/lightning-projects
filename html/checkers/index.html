<html>
    <head>
        <title>Checkers</title>
        <style>
            * {
                font-family: monospace;
            }
            .checker-board {
                border-collapse:collapse;
                border:1px solid #000000; 
            }
            .checker-cell {
                border:1px solid #000000;
                width: 75px;
                height: 75px;
                text-align: center;
            }
            .checker-cell.over-legal {
                border: 2px dashed #00FF00;
            }
            .checker-cell.over-illegal {
                border: 2px dashed #FF0000;
            }
            .brown-cell {
                background: brown;
            }
            .red-cell {
                background: lightgray;
            }
            .piece {
                width: 50px;
                height: 50px;
            }
        </style>
    </head>
    <body onload="init()">
        <h1>Checkers</h1>
        <table id="board" class="checker-board">
            
        </table>

        <script>
            const nRows = 8;
            const nCols = 8;
            let board;
            let movingPiece = undefined;
            let dragOverTd = undefined;
            let cellSource = undefined;
            let playerTurn = 'red';
            let pieces;
            let pMap;

            function init() {
                board = initBoard();
                pieces = initPieces();
                pMap = toMap(pieces);

                initTable(board);
                initCell(pieces);

                console.log(board);
                console.log(pieces);
            }

            function toMap(pieces) {
                const m = {};
                for (const piece of pieces) {
                    const row = piece.row;
                    const col = piece.col;

                    if (!m.hasOwnProperty(row)) {
                        m[row] = {}
                    }
                    if (!m[row].hasOwnProperty(col)) {
                        m[row][col] = piece;
                    }
                }
                return m;
            }

            function getCoordinate(id) {
                const tokens = id.split('-');
                const r = +tokens[1];
                const c = +tokens[2];
                return [r, c];
            }

            function getImageCell(imageId) {
                const coord = getCoordinate(imageId);
                const r = coord[0];
                const c = coord[1];
                const cellId = `cell-${r}-${c}`
                const td = document.getElementById(cellId);
                return td;
            }

            function handlePieceDragStart(e) {
                const img = e.srcElement;
                img.style.opacity = '0.1';

                const tokens = img.id.split('-');
                const r = +tokens[1];
                const c = +tokens[2];
                if (r < nRows && c < nCols) {
                    movingPiece = pMap[r][c];
                }

                const td = getImageCell(img.id);
                const data = td.innerHTML;
                e.dataTransfer.setData('text/html', data);
                cellSource = td;
                // console.log(`handlePieceDragStart ${td.id} ${img.id}`);
            }

            function handlePieceDragEnter(e) {
                const img = e.srcElement;
                const td = getImageCell(img.id);
                if (movingPiece) {
                    const tokens = td.id.split('-');
                    const r = +tokens[1];
                    const c = +tokens[2];

                    const isLegalMove = movingPiece.isLegalMove(r, c);
                    const clazz = isLegalMove ? 'over-legal' : 'over-illegal';
                    td.classList.add(clazz);
                    dragOverTd = td;
                }
                // console.log(`handlePieceDragEnter ${td.id}`);
            }

            function handlePieceDragOver(e) {
                const img = e.srcElement;
                const td = getImageCell(img.id);
                if (movingPiece) {
                    const tokens = td.id.split('-');
                    const r = +tokens[1];
                    const c = +tokens[2];

                    td.classList.add(movingPiece.isLegalMove(r, c) ? 'over-legal' : 'over-illegal');
                    dragOverTd = td;
                }
                // console.log(`handlePieceDragOver ${td.id}`);
            }

            function handlePieceDragLeave(e) {
                const img = e.srcElement;
                const td = getImageCell(img.id);
                td.classList.remove('over-illegal');
                // console.log('handlePieceDragLeave');
            }

            function handlePieceDragDrop(e) {
                const img = e.srcElement;
                const td = getImageCell(img.id);
                handleDrop(td);
            }

            function handlePieceDragEnd(e) {
                const img = e.srcElement;
                img.style.opacity = '1.0';
                movingPiece = undefined;
                cellSource = undefined;
                // console.log('handlePieceDragEnd');
            }

            function initCell(pieces) {
                for (const piece of pieces) {
                    const id = `img-${piece.row}-${piece.col}`
                    const img = document.createElement('img');
                    img.id = id;
                    img.src = piece.image;
                    img.className = 'piece';
                    img.setAttribute('draggable', 'true');
                    img.addEventListener('dragstart', handlePieceDragStart, false);
                    img.addEventListener('dragenter', handlePieceDragEnter, false);
                    img.addEventListener('dragover', handlePieceDragOver, false);
                    img.addEventListener('dragleave', handlePieceDragLeave, false);
                    img.addEventListener('drop', handlePieceDragDrop, false);
                    img.addEventListener('dragend', handlePieceDragEnd, false);

                    const cellId = `cell-${piece.row}-${piece.col}`;
                    const cell = document.getElementById(cellId);
                    cell.appendChild(img);
                }
            }

            function handleCellDragStart(e) {
                const td = e.srcElement;
                if (!td.id.startsWith('cell')) {
                    return;
                }
            }

            function handleCellDragEnter(e) {
                const td = e.srcElement;
                if (!td.id.startsWith('cell')) {
                    return;
                }
                // console.log(`handleCellDragEnter ${td.id}`);
            }

            function handleCellDragOver(e) {
                if (e.preventDefault) {
                    e.preventDefault();
                }

                e.dataTransfer.dropEffect = 'move';

                const td = e.srcElement;
                if (!td.id.startsWith('cell')) {
                    return;
                }

                const tokens = td.id.split('-');
                const r = +tokens[1];
                const c = +tokens[2];
                if (movingPiece) {
                    td.classList.add(movingPiece.isLegalMove(r, c) ? 'over-legal' : 'over-illegal');
                    dragOverTd = td;
                }
                // console.log(`handleCellDragOver ${td.id}`);
            }

            function handleDrop(cellTarget) {
                if (!(movingPiece && cellSource && cellTarget)) {
                    return;
                }

                const sourceCoord = getCoordinate(cellSource.id);
                const targetCoord = getCoordinate(cellTarget.id);

                const sR = sourceCoord[0];
                const tR = targetCoord[0];

                const sC = sourceCoord[1];
                const tC = targetCoord[1];

                if (sR === tR && sC === tC) {
                    // source and target are the same
                    return;
                }

                if (!movingPiece.isLegalMove(tR, tC)) {
                    // illegal move
                    return;
                }

                cellTarget.innerHTML = cellSource.innerHTML;
                cellTarget.classList.remove('over-legal');
                cellSource.innerHTML = '';

                const img = document.getElementById(`img-${sR}-${sC}`);
                img.style.opacity = '1.0';
                img.id = `img-${tR}-${tC}`;
                img.addEventListener('dragstart', handlePieceDragStart, false);
                img.addEventListener('dragenter', handlePieceDragEnter, false);
                img.addEventListener('dragover', handlePieceDragOver, false);
                img.addEventListener('dragleave', handlePieceDragLeave, false);
                img.addEventListener('drop', handlePieceDragDrop, false);
                img.addEventListener('dragend', handlePieceDragEnd, false);

                const piece = pMap[sR][sC];
                piece.row = tR;
                piece.col = tC;

                delete pMap[sR][sC];
                if (!pMap.hasOwnProperty(tR)) {
                    pMap[tR] = {};
                }
                pMap[tR][tC] = piece;

                playerTurn = 'red' === playerTurn ? 'black' : 'red';
            }

            function handleCellDragLeave(e) {
                const td = e.srcElement;
                if (!td.id.startsWith('cell')) {
                    return;
                }
                td.classList.remove('over-legal');
                td.classList.remove('over-illegal');
                // console.log(`handleCellDragLeave ${td.id}`);
            }

            function handleCellDrop(e) {
                if (e.stopPropagation) {
                    e.stopPropagation();
                }

                const td = e.srcElement;
                if (!td.id.startsWith('cell')) {
                    return;
                }
                
                handleDrop(td);

                return false;
            }

            function handleCellDragEnd(e) {
                if (dragOverTd) {
                    dragOverTd.classList.remove('over-legal');
                    dragOverTd.classList.remove('over-illegal');
                    dragOverTd = undefined;
                }

                const td = getImageCell(e.srcElement.id);
                if (!td.id.startsWith('cell')) {
                    return;
                }
                // console.log(`handlePieceDragEnd ${td.id}`);
            }

            function initTable(board) {
                const table = document.getElementById('board');
                for (let r = 0; r < nRows; r++) {
                    const row = table.insertRow(r);
                    for (let c = 0; c < nCols; c++) {
                        const cell = row.insertCell(c);
                        cell.id = `cell-${r}-${c}`;
                        cell.classList.add('checker-cell');
                        cell.classList.add(board[r][c].color === 'brown' ? 'brown-cell' : 'red-cell');
                        cell.addEventListener('dragstart', handleCellDragStart, false);
                        cell.addEventListener('dragenter', handleCellDragEnter, false);
                        cell.addEventListener('dragover', handleCellDragOver, false);
                        cell.addEventListener('dragleave', handleCellDragLeave, false);
                        cell.addEventListener('drop', handleCellDrop, false);
                        cell.addEventListener('dragend', handleCellDragEnd, false);
                    }
                }
            }

            function initPieces() {
                const pieces = new Array();
                for (let r = 0; r < nRows; r++) {
                    for (let c = 0; c < nCols; c++) {
                        const piece = getPiece(r, c);
                        if (piece) {
                            pieces.push(piece);
                        }
                    }
                }
                return pieces;
            }

            function initBoard() {
                const board = getBoard();
                return board;
            }

            function getBoard() {
                const board = Array(nRows);
                for (let r = 0; r < nRows; r++) {
                    board[r] = new Array(nCols);
                    for (let c = 0; c < nCols; c++) {
                        board[r][c] = getCell(r, c);
                    }
                }
                return board;
            }

            function getCell(r, c) {
                return {
                    row: r,
                    col: c,
                    color: getCellColor(r, c)
                }
            }

            function getCellColor(r, c) {
                if (r % 2 === 0 && c % 2 === 0) {
                    return 'white';
                } else if (r % 2 === 0 && c % 2 !== 0) {
                    return 'brown';
                } else if (r % 2 !== 0 && c % 2 === 0) {
                    return 'brown';
                } else {
                    return 'white';
                }
            }

            function isCellOccupied(r, c) {
                if (pMap.hasOwnProperty(r) && pMap[r].hasOwnProperty(c)) {
                    return true;
                }
                return false;
            }

            function isCaptureMove(color, sR, sC, tR, tC) {
                let dR = color === 'black'? 2 : -2;
                let rcR = sR + dR;
                let lcR = sR + dR;
                
                let rcC = sC + 2;
                let lcC = sC - 2;

                const leftValid = tR === lcR && tC === lcC && 0 <= tR && tR < nRows && 0 <= tC && tC < nCols;
                const rightValid = tR === rcR && tC === rcC && 0 <= tR && tR < nRows && 0 <= tC && tC < nCols;

                if (!leftValid && !rightValid) {
                    console.log('not left or right valid');
                    return false;
                }

                dR = color === 'black'? 1 : -1;
                rcR = sR + dR;
                lcR = sR + dR;

                rcC = sC + 1;
                lcC = sC - 1;

                if (isCellOccupied(rcR, rcC) && rightValid) {
                    return true;
                }

                if (isCellOccupied(lcR, lcC) && leftValid) {
                    return true;
                }

                return false;
            }

            function getPiece(r, c) {
                const cellColor = getCellColor(r, c);
                let color = undefined;
                let image = undefined;

                if (r < 2 && cellColor === 'white') {
                    color = 'black';
                    image = 'images/black.png';
                } else if (r > 5 && cellColor === 'white') {
                    color = 'red';
                    image = 'images/red.png';
                }
                
                if (color && image) {
                    return {
                        row: r,
                        col: c,
                        isCrowned: false,
                        color: color,
                        image: image,
                        isLegalMove: function(r, c) {
                            // wait your turn
                            if (this.color !== playerTurn) {
                                return false;
                            }

                            // there can be no pieces on the brown squares
                            const cellColor = getCellColor(r, c);
                            if (cellColor === 'brown') {
                                return false;
                            }

                            // cannot move to an occupied space
                            if (isCellOccupied(r, c)) {
                                return false;
                            }

                            if (this.color === 'black' && this.row + 1 === r) {
                                // black can move down
                                return true;
                            } else if (this.color === 'red' && this.row - 1 === r) {
                                // red can move up
                                return true;
                            } else if (isCaptureMove(this.color, this.row, this.col, r, c)) {
                                // can capture
                                return true;
                            }
                            return false;
                        }
                    }
                }
                return undefined;
            }
        </script>
    </body>
</html>